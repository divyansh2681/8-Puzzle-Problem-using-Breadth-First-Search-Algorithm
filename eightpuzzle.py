# -*- coding: utf-8 -*-
"""eightpuzzle.ipynb

Automatically generated by Colaboratory.

"""

import numpy as np
from collections import deque

"""creating Node class"""

class Node():
    def __init__(self, matrix_data, Node_Index_i, Parent_Node_Index_i):
        self.matrix_data = matrix_data
        self.Node_Index_i = Node_Index_i
        self.Parent_Node_Index_i = Parent_Node_Index_i

"""Initialization function"""

def initialize():
    g = np.array([[1, 4, 7], [2, 5, 8], [3, 6, 0]])  ## STATE OF GOAL NODE ##
    initial_state = np.array([[4, 7, 0],[1, 2, 8],[3, 5, 6]])   ## STATE OF INITIAL NODE ##
    current_node = Node(initial_state, 1, 0)
    created_nodes = []  ##### generated nodes 
    created_nodes = deque(created_nodes)
    created_nodes.append(current_node)
    e = [] ## nodes whichh have already been explored, explored_list
    a = [] ## static list only adding all the created nodes, all_nodes 
    a.append(current_node)
    mld = []  ### list for storing only the matrix data of each created node
    mld.append(initial_state)  
    b = [] ### list for storing backtracking matrices 
    return created_nodes, a, e, g, mld, b

"""function for getting position of blank tile in a matrix"""

def blank_tile(present_node):
    for i in range(3):
        for j in range(3):
            if (present_node.matrix_data[i][j] == 0):
                return i, j

"""function to create a new Node object"""

def new_node_attribute(present_node, child):
    new_node_matrix_data = child
    new_node_Node_Index_i = all_nodes[-1].Node_Index_i + 1
    new_node_Parent_Node_Index_i = present_node.Node_Index_i
    latest_node = Node(new_node_matrix_data, new_node_Node_Index_i, new_node_Parent_Node_Index_i)  ## creating new node object
    all_nodes.append(latest_node) ## appending that object to list
    generated_nodes.append(latest_node)
    matrix_data_list.append(latest_node.matrix_data) ## appending only the matrix data of the new node, this list is used to check if that node is already present or not
    return latest_node

"""checking node validity and then checking if the goal has been reached or not"""

def validity(present_node, child):
    
    for p in matrix_data_list:
            
        if (np.array_equal(child, p)):  ## comparing two arrays
            return False
        else:
            
            new_node_attribute(present_node, child)
            if (np.array_equal(child, goal)):
                print('Goal reached')
                return True
            else:
                return False

"""functions for moving left, right, up, down """

def ActionMoveRight(present_node):
    i, j = blank_tile(present_node)
    if (j == 2):
        
        return False
    else:
        temp = np.copy(present_node.matrix_data)    
        
        temp[i, j + 1] = 0
        temp[i, j] = present_node.matrix_data[i, j + 1]
        child = temp
        
        if (validity (present_node, temp)):
            return True, present_node 

    return False        

        
def ActionMoveLeft(present_node):
    i, j = blank_tile(present_node)
    if (j == 0):
        
        return False
    else:
        temp = np.copy(present_node.matrix_data)
        temp[i, j - 1] = 0
        temp[i, j] = present_node.matrix_data[i, j - 1]
        child = temp
        
        if (validity (present_node, temp)):
            return True
    return False

def ActionMoveUp(present_node):
    i, j = blank_tile(present_node)
    if (i == 0):
        
        return False
    else:
        temp = np.copy(present_node.matrix_data)  
        temp[i - 1, j] = 0
        temp[i, j] = present_node.matrix_data[i - 1, j]
        child = temp
        
        if (validity (present_node, temp)):
            return True 

    return False
                            
def ActionMoveDown(present_node):
    i, j = blank_tile(present_node)
    if (i == 2):
        
        return False
    else:
        temp = np.copy(present_node.matrix_data)  
        temp[i + 1, j] = 0
        temp[i, j] = present_node.matrix_data[i + 1, j]
        child = temp
         
        if (validity (present_node, temp)):
            return True 

    return False

"""Movement function"""

def movement(present_node):
    if (not ActionMoveUp(present_node)):
        if (not ActionMoveDown(present_node)):
            if (not ActionMoveRight(present_node)):
                if (not ActionMoveLeft(present_node)):
                    return False
                else:     
                    return True
            else: 
                return True
        else:
            return True
    else:
        return True

"""Function for backtracking"""

def backtrack(present_node, all_nodes, b):
    count = 0
    while (present_node.Parent_Node_Index_i != 0):
        if (count == 0):
            temp = all_nodes[-1].Parent_Node_Index_i
            b.append(all_nodes[-1])
        else:
            temp = all_nodes[data].Parent_Node_Index_i
        data = temp - 1
        b.append(all_nodes[data])
        count = count + 1
        present_node = all_nodes[data]
        
    for i in b:
        print('Parent Node Index', '\t', i.Parent_Node_Index_i, '\n', 'State', '\t', i.matrix_data, '\n', 'Node Index', '\t', i.Node_Index_i)   

    a = b
    a.reverse()
    
    with open('nodePath.txt', 'w') as f:
        for i in a:    
            stri = str(((i.matrix_data).transpose()).flatten())   ## when writing a file, brackets of the matrix should be removed
            l = len(stri)
            f.write(stri[1:l-1]) ## writing from index 1 to index (length - 1) to remove brackets
            f.write('\n')

"""Function to explore nodes"""

def func_explore(goal, generated_nodes, all_nodes, explored_list):
    
      if (len(generated_nodes)>0):
          temp = generated_nodes.popleft()
          explored_list.append(temp)
          if (not movement(temp)):   
          
              return True
          else:
              return False
      else:
          print("unsolvable")
          return False

"""Below is the main function"""

path = []
generated_nodes, all_nodes, explored_list, goal, matrix_data_list, back_track = initialize()
while(func_explore(goal, generated_nodes, all_nodes, explored_list)):
  func_explore(goal, generated_nodes, all_nodes, explored_list)
  
backtrack(all_nodes[-1], all_nodes, back_track)
print('Program has ended')

"""Creating Nodes.txt"""

with open('Nodes.txt', 'w') as f:
    for i in explored_list:
        stri = str(((i.matrix_data).transpose()).flatten())
        l = len(stri)
        f.write(stri[1:l-1])
        f.write('\n')

"""Creating NodesInfo.txt"""

with open('NodesInfo.txt', 'w') as f:
    f.write('Node Index')
    f.write(str('\t'))
    f.write('Parent Node Index')
    f.write('\n')
    for item in all_nodes:            
        f.write(str(item.Node_Index_i))
        f.write(str('\t'))
        f.write(str('\t'))
        f.write(str('\t'))
        f.write(str(item.Parent_Node_Index_i))
        f.write(str('\n'))
